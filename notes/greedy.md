<!-- GFM-TOC -->
* [贪心算法部分笔记总结](#贪心算法部分笔记总结)
    * [贪心基础](#贪心基础)
    * [贪心算法与动态规划的关系](#贪心算法与动态规划的关系)
    * [参考资料](#参考资料)
<!-- GFM-TOC -->
# 贪心算法部分笔记总结
## 贪心基础
相关题目：
* [分发饼干](#455)
* [判断子序列](#392)
* [买卖股票的最佳时机（2）](#122)
### 455
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

注意：

你可以假设胃口值为正。
一个小朋友最多只能拥有一块饼干。

示例 1:

输入: [1,2,3], [1,1]

输出: 1

解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
示例 2:

输入: [1,2], [1,2,3]

输出: 2

解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
- 分析：
贪心策略：尽可能大地满足孩子的贪心值。
- 实现：
````java
public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int gi=g.length-1;
        int si=s.length-1;
        int count=0;
        //从大到小遍历
        while (gi>=0&&si>=0){
            if (s[si]>=g[gi]){
                count++;
                gi--;
                si--;
            }else {
                gi--;
            }
        }
        return count;
    }
````
### 392
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

示例 1:
s = "abc", t = "ahbgdc"

返回 true.

示例 2:
s = "axc", t = "ahbgdc"

返回 false.

后续挑战 :

如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

- 分析：

只需要在t中搜索即可，贪心策略体现在每次只比较第一个匹配的字符，同时设置一个计数器来记录t中匹配的字符数，
如果计数器等于s的长度则成功；如果循环结束则表示没有全部匹配到t中的字符，则失败。
- 实现：
```java
public boolean isSubsequence(String s, String t) {
        int sLen = s.length();
        int tLen = t.length();
        if (sLen==0){
            return true;
        }
        int sCount=0;
        for (int i = 0; i < tLen; i++) {
            if (s.charAt(j)==t.charAt(i)){
                sCount++;
            }
            if (sCount==sLen){
                return true;
            }
        }
        return false;
    }
```
### 122
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例 3:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
- 分析：

由于不限制交易次数，那么可以考虑使用贪心算法；
贪心策略：体现在每当股票价格上升的时候就尽可能进行交易

- 实现：
```java
public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n==0||n==1){
            return 0;
        }
        int max=0;
        for (int i = 1; i < n; i++) {
            if (prices[i]>prices[i-1]){
                max+=prices[i]-prices[i-1];
            }
        }
        return max;
    }
```

## 贪心算法与动态规划的关系
相关题目：
* [重叠区间](#455)
### 435
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:

可以认为区间的终点总是大于它的起点。
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
示例 1:

输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
示例 2:

输入: [ [1,2], [1,2], [1,2] ]

输出: 2

解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
示例 3:

输入: [ [1,2], [2,3] ]

输出: 0

解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
- 分析：
使用贪心算法，首先将区间按照结尾做升序排列；由于题目中要求求出需要移除区间的最小数量，使剩余区间互不重叠，等价于求出总区间数减去剩余区间互不重叠的最大区间数
（min=n-max）

贪心策略：尽量选择结尾靠前的区间，每次选择结尾最早的，并且和前一个区间没有重叠的；在遍历过程中记录区间数，遍历结束最后得到的就是不重叠的最大区间数(res)，用总区间数减去res即可。
- 实现：
```java
public class Interval {
      int start;
      int end;
      Interval() { start = 0; end = 0; }
      Interval(int s, int e) { start = s; end = e; }
  }
  private class  myComparator implements Comparator<Interval>{
      @Override
      public int compare(Interval o1, Interval o2) {
          if (o1.end!=o2.end){
              return o1.end-o2.end;
          }else {
              return o1.start-o2.start;
          }
      }
  }

    //使得区间按照结尾从小到大排列
    //贪心策略：尽量选择结尾靠前的区间，每次选择结尾最早的，并且和前一个区间没有重叠的
    public int eraseOverlapIntervals(Interval[] intervals) {
        if (intervals.length==0){
            return 0;
        }
        Arrays.sort(intervals,new  myComparator() );
        int res=1;
        int pre=0;  //遍历过程中之前使用的区间索引
        for (int i = 1; i < intervals.length; i++) {
            //如果区间没有重叠的时候
            if (intervals[i].start>=intervals[pre].end){
                res++;
                pre=i;  //记录
            }
        }
        return intervals.length-res;
    }
```
# 参考资料

[玩儿转算法面试 - 课程官方代码仓](https://github.com/liuyubobobo/Play-with-Algorithm-Interview)
