<!-- GFM-TOC -->
* [二叉树和递归部分笔记总结](#二叉树和递归部分笔记总结)
    * [二叉树天然的递归结构](#二叉树天然的递归结构)
    * [翻转二叉树](#翻转二叉树)
   
* [参考资料](#参考资料)
<!-- GFM-TOC -->
# 二叉树和递归部分笔记总结
## 二叉树天然的递归结构
- 相关题目：
    *[二叉树的最大深度](#104)
    *[二叉树的最小深度](#111)
### 104

- 二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。

- 分析：

求二叉树的最大深度，就是求二叉树的深度；这里可以很好的应用递归的方法：

首先确定递归的**终止条件**，即二叉树为空的时候，此时深度为0；接着，确定**递归的过程**，
即从根结点的**左右子树**中找出最大的深度加上1（根结点）就是二叉树的最大深度。


- 实现：
```java
public int maxDepth(TreeNode root) {
        if (root==null){
            return 0;
        }

        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;

    }
``` 
### 111
- 二叉树的最小深度

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回它的最小深度  2.
- 分析：

这一题与上一道题类似，同样使用递归的方法来求解，但有一些陷阱需要注意。

首先，确定递归的终止条件，即结点为空的时候，此时深度为0；接着关键的是在确定递归的过程，
当根结点的左右子树均不空的时候，这时取左右子树深度的较小值加1（根节点），**而当左右子树中有一边
为空的时候，这时取左右子树深度的较大值加1。**

>因为当只有一边有结点的时候需要记录此时的深度，如果还是取较小值的时候(任何一个自然数和0相比，较小值永远为0)，则会丢失此时的子结构的深度。


- 实现：
```java
public int minDepth(TreeNode root) {
        if (root==null){
            return 0;
        }
        //当左右子树均不为空的时候，取左右子树中的最小值
        if (root.left!=null&&root.right!=null){
            return Math.min(minDepth(root.right),minDepth(root.left))+1;
        }
        //当左右子树不是都有结点的时候，取左右子树的最大深度
        return Math.max(minDepth(root.right),minDepth(root.left))+1;

    }
```

## 翻转二叉树 
## 注意递归的终止条件 

# 参考资料
[玩儿转算法面试 - 课程官方代码仓](https://github.com/liuyubobobo/Play-with-Algorithm-Interview)

